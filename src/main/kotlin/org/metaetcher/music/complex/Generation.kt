package org.metaetcher.music.complex

import org.apache.commons.math3.complex.Complex
import kotlin.math.PI
import kotlin.math.cos
import kotlin.math.sin

/**build a complex sequence for the supplied parameters
 * @param z the starting complex number
 * @param zc the constant complex number
 * @param max the maximum number of iterations
 * @param radius the radius outside which iteration stops
 * @param stop0 if true, stop when the absolute value of the complex number is 0.0
 * @param f the iterative function
 * @return a sequence of complex numbers
 */
fun genComplexSequence(z: Complex, zc: Complex, max: Int, radius: Double, stop0: Boolean, f: (Complex, Complex) -> Complex
): Sequence<Complex> {
    var zn = Complex(z.real, z.imaginary)
    var i = 0
    return generateSequence(zn) {
        zn = f(zn, zc)
        if ((++i >= max) || (zn.abs() >= radius) || (stop0 && zn.abs() == 0.0)) null else zn
    }
}

/** build a complex sequence for the supplied parameters using the mandelbrot iterative function
 * @param z the starting complex number
 * @param zc the constant complex number
 * @param max the maximum number of iterations
 * @param radius the radius outside which iteration stops
 * @param stop0 if true, stop when the absolute value of the complex number is 0.0
 * @return a sequence of complex numbers
 */
fun complexSeq(z: Complex, zc: Complex, max: Int, radius: Double, stop0: Boolean = true): Sequence<Complex> =
    genComplexSequence(z, zc, max, radius, stop0, ::mand)

/** the mandelbrot iterative function f(z) = z^2 + zc
 * @param zn the current complex number
 * @param zc the constant complex number (often the same as zn)
 * @return the resulting complex number
 */
fun mand(zn: Complex, zc: Complex): Complex = zn.multiply(zn).add(zc)

/** a particular algorithm for generating a sequence of complex numbers that can be used to generate music, etc.
 * @param sourceZs the source set of complex numbers
 * @param max the maximum number of iterations
 * @param iterParams the iteration parameters, which are the iteration numbers at which to return a result
 * @param zConst the constant complex number if using a custom iterative function
 * @param f the iterative function
 * @return a list of results
 */
fun algoA(sourceZs: Iterable<Complex>, max: Int, iterParams: Iterable<Int>, zConst: Complex?,
          f: (Complex, Complex) -> Complex = ::mand
): List<Result> {
    val results = mutableListOf<Result>()
    sourceZs.forEach { z ->
        val result = mutableListOf<Complex>()
        val eval = mutableListOf<Complex>()
        val seq = genComplexSequence(z, zConst ?: z, max, 3.5, true, f)
        seq.forEachIndexed { i, complex ->
            eval.add(complex)
            if (i in iterParams) result.add(complex)
            else if (i == max - 1) result.add(complex)
        }
        if (result.isNotEmpty()) results.add(Result(eval, result))
    }
    return results
}

/** A specialized version of [algoA] that operates specifically on a circle of complex numbers
 * @param num the number of points to generate on the circle
 * @param startCenter the center of the circle
 * @param startRadius the radius of the circle
 * @param iterMax the maximum number of iterations
 * @param iterParams the iteration parameters, which are the iteration numbers at which to return a result
 * @param zConst the constant complex number if using a custom iterative function
 * @param f the iterative function
 * @return a list of results
 * */
fun algoACircle(num: Int, startCenter: Complex, startRadius: Double, iterMax: Int, iterParams: Iterable<Int>,
    zConst: Complex?, f: (Complex, Complex) -> Complex = ::mand) =
    algoA(buildCircle(startCenter, startRadius, num), iterMax, iterParams, zConst, f)

/** generate a list of complex numbers within a circle
 * @param center the center of the circle
 * @param radius the radius of the circle
 * @param num the number of points to generate
 * @return a list of complex numbers
 */
fun buildCircle(center: Complex, radius: Double, num: Int): List<Complex> {
    val increment = 2 * PI / num
    return (0 until num).map {
        center.add(Complex(radius * cos(it * increment), radius * sin(it * increment)))
    }
}

/** generate a list of complex numbers within a rectangular grid, which can be used to generate images, music, etc.
 * @param coords specifies the coordinate system
 * @return a list of complex numbers
 */
fun buildGrid(coords: Coords): List<Complex> {
    val result = mutableListOf<Complex>()
    for (x in 0 until coords.xNum) {
        for (y in 0 until coords.yNum) {
            result.add(coords.complex(x, y))
        }
    }
    return result
}

/** a data class for the result of an algorithm
 * @param evalSeq the sequence of complex numbers that were evaluated
 * @param results the resulting sequence generated by the algorithm
 */
data class Result(val evalSeq: List<Complex>, val results: List<Complex>)

/** find the attractor of a complex number under a particular iterative function
 * @param z the starting complex number
 * @param z0 the constant complex number
 * @param f the iterative function
 * @param maxIter the maximum number of iterations
 * @return the attractor (or null if none) and the number of iterations
 */
fun findAttractor(z: Complex, z0:Complex, f: (Complex,Complex)->Complex, maxIter:Int=1000) : AttractorResult {
    var i = 0
    var c1 = Complex(z.real, z.imaginary)
    var c2 = Complex(100.0, 100.0)
    while (i++ < maxIter && !c1.approxEqual(c2)) {
        c2 = Complex(c1.real, c1.imaginary)
        c1 = f.invoke(c1, z0)
    }
    return if (i < maxIter+1) AttractorResult(c1, i) else AttractorResult(null, i)
}
data class AttractorResult(val attractor:Complex?, val i:Int)